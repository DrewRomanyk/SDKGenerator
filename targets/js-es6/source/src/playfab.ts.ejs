import { Promise } from "es6-promise";

export const sdk_version = "<%- sdkVersion %>";
export const buildIdentifier = "<%- buildIdentifier %>";

export const errorTitleId = "Must have playfab.settings.titleId set to call this method";
export const errorLoggedIn = "Must be logged in to call this method";
export const errorSecretKey = "Must have playfab.settings.DeveloperSecretKey set to call this method";

export interface IPlayFabRequestCommon { }
export interface IPlayFabError {
    code: number;
    status: string;
    error: string;
    errorCode: number;
    errorMessage: string;
    errorDetails?: { [key: string]: string[]};
}
export interface IPlayFabResultCommon extends IPlayFabError { }
export interface IPlayFabSuccessContainer<TResult extends IPlayFabResultCommon> extends IPlayFabError {
    data: TResult;
}

export interface ISettings {
    productionUrl: string,
    verticalName: string | undefined,
    titleId: string | undefined,
    globalErrorHandler: string | undefined,
    developerSecretKey: string | undefined,
<% if (hasClientOptions) {
%>
    advertisingIdType: string | undefined,
    advertisingIdValue: string | undefined,
    disableAdvertising: boolean,
    AD_TYPE_IDFA: string,
    AD_TYPE_ANDROID_ID: string,
<% } %>};

export let settings: ISettings = {
    productionUrl: ".playfabapi.com",
    verticalName: <%- getVerticalNameDefault() %>, // The name of a customer vertical. This is only for customers running a private cluster. Generally you shouldn't touch this
    titleId: undefined, // You must set this value for PlayFabEs6Sdk to work properly (Found in the Game Manager for your title, at the PlayFab Website)
    globalErrorHandler: undefined,
    developerSecretKey: undefined, // You must set this value for PlayFabEs6Sdk to work properly (Found in the Game Manager for your title, at the PlayFab Website)
<% if (hasClientOptions) {
%>
    advertisingIdType: undefined, // Set this to the appropriate AD_TYPE_X constant below
    advertisingIdValue: undefined, // Set this to corresponding device value

    // disableAdvertising is provided for completeness, but changing it is not suggested
    // Disabling this may prevent your advertising-related PlayFab marketplace partners from working correctly
    disableAdvertising: false,
    AD_TYPE_IDFA: "Idfa",
    AD_TYPE_ANDROID_ID: "Adid",
<% } %>};

interface IInternalSettings {
    entityToken: string | undefined;
    sessionTicket: string | undefined;
    requestGetParams: Record<string, string>,
}

/** @internal */
export let _internalSettings: IInternalSettings = {
    entityToken: undefined,
    sessionTicket: undefined,
    requestGetParams: {
        sdk: "Es6SDK-" + sdk_version
    },
};

export function GetServerUrl(): string {
    const baseUrl = settings.productionUrl;
    if (!(baseUrl.substring(0, 4) === "http")) {
        if (settings.verticalName) {
            return "https://" + settings.verticalName + baseUrl;
        } else {
            return "https://" + settings.titleId + baseUrl;
        }
    } else {
        return baseUrl;
    }
}

function getCompleteUrl(urlStr: string): string {
    const urlArr = [urlStr]; //make a new array for the URL
    const getParams = _internalSettings.requestGetParams;
    if (getParams !== undefined) {
        let firstParam = true;
        for (const key in getParams) {
            if (firstParam) {
                urlArr.push("?");
                firstParam = false;
            } else {
                urlArr.push("&");
            }
            urlArr.push(key);
            urlArr.push("=");
            urlArr.push(getParams[key]);
        }
    }

    return urlArr.join("");
}

export function createErrorResponse(error: any): IPlayFabError {
    return {
        code: 503, // Service Unavailable
        status: "Service Unavailable",
        error: "Connection error",
        errorCode: 2, // PlayFabErrorCode.ConnectionError
        errorMessage: error
    };
}

export function makeRequest<T extends IPlayFabResultCommon>(urlStr: string, request: IPlayFabRequestCommon | undefined, authType: string | undefined, authValue: string | undefined): Promise<T> {
    return new Promise<T>((resolve, reject) => {
        try {
            let req:IPlayFabRequestCommon = request as IPlayFabRequestCommon;
            if (request === undefined || request === undefined) {
                req = {};
            }
            const requestBody = JSON.stringify(req);
            const completeUrl = getCompleteUrl(urlStr);
            if (completeUrl.toLowerCase().indexOf("https:") !== 0) {
                reject("Unsupported protocol");
            }

            const xhr = new XMLHttpRequest();
            xhr.open("POST", completeUrl, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.setRequestHeader("X-PlayFabSDK", "Es6SDK-" + sdk_version);
            if (authType && authValue) {
                xhr.setRequestHeader(authType, authValue);
            }
            xhr.onload = function() {
                try {
                    const responseJson = JSON.parse(xhr.responseText);
                    if (responseJson.status === undefined && responseJson.data === undefined) {
                        reject(createErrorResponse("Not expected json response: " + JSON.stringify(responseJson)));
                    } else {
                        const response: IPlayFabSuccessContainer<T> = responseJson;
                        if (response.status !== "OK" || response.error) {
                            reject(response);
                        } else if (response.data.error) {
                            reject(response.data);
                        } else {
                            resolve(response.data);
                        }
                    }
                } catch (error) {
                    reject(createErrorResponse(error));
                }
            }
            xhr.onerror = function() {
                reject(createErrorResponse(xhr.responseText));
            }
            xhr.send(requestBody);
        } catch (error) {
            reject(error);
        }
    });
}
